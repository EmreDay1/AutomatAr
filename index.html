<!DOCTYPE html>
<html>

<head>
  <title>Basic Multi-Marker AR</title>

  <!-- Libraries -->
  <script type="text/javascript" src="libs/Three.js"></script>
  <script type="text/javascript" src="libs/STLLoader.js"></script>
  <script type="text/javascript" src="src/svd.js"></script>
  <script type="text/javascript" src="src/posit1.js"></script>
  <script type="text/javascript" src="src/cv.js"></script>
  <script type="text/javascript" src="src/aruco.js"></script>
  <script type="text/javascript" src="src/atf.js"></script>
  <script type="text/javascript" src="src/multiS.js"></script>
  <script type="text/javascript" src="src/optic.js"></script>

  <script type="text/javascript">
    var video, canvas, context, imageData, detector, posit;
    var renderer, scene, camera, backgroundScene, backgroundCamera, videoTexture;
    var adaptiveFilter, multiScaleDetector, opticalFlowTracker;
    var useAdaptiveFilter = false;
    var useMultiScale = false;
    var useOpticalFlow = false;
    var modelSize = 35.0; // millimeters
    var debugElement;

    // We will cache all STL geometries here once loaded
    var stlCache = {};

    // Define all six scenarios:
    // Each scenario is identified by an "identifierTag" 
    // and holds an array of "object" { tag, stl } 
    // which links each object-tag to an STL file.
    var scenarios = [
      {
        name: "Cam-A",
        identifierTag: 0,
        objects: [
          { tag: 6, stl: "sea_models/stringray.stl" }
        ]
      },
      {
        name: "Cam-C",
        identifierTag: 1,
        objects: [
          { tag: 7, stl: "sea_models/jellyfish.stl" }
        ]
      },
      {
        name: "Crank",
        identifierTag: 2,
        objects: [
          { tag: 8, stl: "sea_models/dolphin.stl" }
        ]
      },
      {
        name: "Gear-A",
        identifierTag: 3,
        objects: [
          { tag: 9, stl: "sea_models/octopus.stl" }
        ]
      },
      {
        name: "Gear-B",
        identifierTag: 4,
        objects: [
          { tag: 10, stl: "sea_models/fishes.stl" }
        ]
      },
      {
        name: "Gear-C",
        identifierTag: 5,
        objects: [
          { tag: 11, stl: "sea_models/sea_turtle.stl" }
        ]
      }
    ];

    // We'll reuse the same STLLoader for all loads
    var stlLoader = null;

    function onLoad() {
      // Initialize DOM elements
      video = document.getElementById("video");
      canvas = document.getElementById("canvas");
      context = canvas.getContext("2d");
      debugElement = document.getElementById("debug");
      
      // Set canvas dimensions
      canvas.width = 320;
      canvas.height = 240;
      
      log("Initializing...");

      // Initialize camera
      initCamera();
      
      // Initialize detector
      detector = new AR.Detector();
      posit = new POS.Posit(modelSize, canvas.width);
      log("Base detector initialized");
      
      // Initialize filters
      initFilters();
      
      // Initialize renderer and scene
      initRenderer();

      // Initialize STLLoader
      stlLoader = new THREE.STLLoader();

      // Start animation loop
      requestAnimationFrame(tick);
    }
    
    function initFilters() {
      adaptiveFilter = new AdaptiveThresholdFilter({
        blockSize: 21,
        C: 5,
        useIntegralImage: true
      });
      log("Adaptive threshold filter initialized");
      
      multiScaleDetector = new MultiScaleDetector({
        detector: detector, 
        scales: [1.0, 0.5, 1.5],
        confidenceThreshold: 0.3
      });
      log("Multi-scale detector initialized");
      
      opticalFlowTracker = new OpticalFlowTracker({
        winSize: 15,
        maxError: 10000,
        maxMotion: 50,
        maxTrackedFrames: 30
      });
      log("Optical flow tracker initialized");
      
      document.getElementById('useATF').checked = useAdaptiveFilter;
      document.getElementById('useMultiScale').checked = useMultiScale;
      document.getElementById('useOpticalFlow').checked = useOpticalFlow;
      
      log("Adaptive Threshold Filter: OFF");
      log("Multi-Scale Detection: OFF");
      log("Optical Flow Tracking: OFF");
    }
    
    function initRenderer() {
      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor(0xffffff, 1);
      renderer.setSize(canvas.width, canvas.height);
      document.getElementById("container").appendChild(renderer.domElement);
      
      // Set up video texture
      videoTexture = new THREE.Texture(video);
      videoTexture.minFilter = THREE.LinearFilter;
      
      // Create background scene with video texture
      backgroundScene = new THREE.Scene();
      backgroundCamera = new THREE.Camera();
      
      var plane = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2, 0),
        new THREE.MeshBasicMaterial({ map: videoTexture, depthTest: false, depthWrite: false })
      );
      plane.material.side = THREE.DoubleSide;
      plane.position.z = -1;
      
      backgroundScene.add(backgroundCamera);
      backgroundScene.add(plane);
      
      // Create main AR scene
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(40, canvas.width / canvas.height, 1, 1000);
      scene.add(camera);
      
      // Add lights
      var ambientLight = new THREE.AmbientLight(0x666666);
      scene.add(ambientLight);
      
      var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
      directionalLight.position.set(0, 0, 1);
      scene.add(directionalLight);
      
      log("Renderer initialized");
    }
    
    function initCamera() {
      log("Initializing camera...");
      
      if (navigator.mediaDevices === undefined) {
        navigator.mediaDevices = {};
      }
      
      if (navigator.mediaDevices.getUserMedia === undefined) {
        navigator.mediaDevices.getUserMedia = function(constraints) {
          var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
          
          if (!getUserMedia) {
            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
          }
    
          return new Promise(function(resolve, reject) {
            getUserMedia.call(navigator, constraints, resolve, reject);
          });
        }
      }
      
      navigator.mediaDevices
        .getUserMedia({ video: true })
        .then(function(stream) {
          log("Camera access granted");
          if ("srcObject" in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }
          video.play();
        })
        .catch(function(err) {
          log("Camera error: " + err.message);
        });
    }
    
    function tick() {
      requestAnimationFrame(tick);
      
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        // Capture frame
        snapshot();
        
        // Update video texture for AR view
        videoTexture.needsUpdate = true;
        
        // Detect markers (base detection first)
        var markers = detector.detect(imageData);
        
        // Apply active filters
        markers = processFilters(markers);
        
        // Draw markers on canvas (2D overlay)
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        drawMarkers(markers);
        
        // Update 3D scene
        updateScene(markers);
        
        // Render both the background (video) and AR scene
        renderer.autoClear = false;
        renderer.clear();
        renderer.render(backgroundScene, backgroundCamera);
        renderer.render(scene, camera);
        
        // Update info
        updateMarkerInfo(markers);
      }
    }
    
    function processFilters(markers) {
      var finalMarkers = markers.slice();
      
      // Adaptive Threshold Filter
      if (useAdaptiveFilter) {
        try {
          var processedImageData = adaptiveFilter.process(imageData);
          var atfMarkers = detector.detect(processedImageData);
          
          // Merge new markers
          for (var i = 0; i < atfMarkers.length; i++) {
            var isNew = true;
            for (var j = 0; j < finalMarkers.length; j++) {
              if (atfMarkers[i].id === finalMarkers[j].id && areMarkersClose(atfMarkers[i], finalMarkers[j])) {
                isNew = false;
                break;
              }
            }
            if (isNew) {
              finalMarkers.push(atfMarkers[i]);
            }
          }
        } catch (err) {
          log("ATF error: " + err.message);
        }
      }
      
      // Multi-scale detection
      if (useMultiScale) {
        try {
          var msMarkers = multiScaleDetector.detect(imageData);
          for (var i = 0; i < msMarkers.length; i++) {
            var isNew = true;
            for (var j = 0; j < finalMarkers.length; j++) {
              if (msMarkers[i].id === finalMarkers[j].id && areMarkersClose(msMarkers[i], finalMarkers[j])) {
                isNew = false;
                break;
              }
            }
            if (isNew) {
              finalMarkers.push(msMarkers[i]);
            }
          }
        } catch (err) {
          log("Multi-scale error: " + err.message);
        }
      }
      
      // Optical flow
      if (useOpticalFlow) {
        try {
          var ofMarkers = opticalFlowTracker.track(imageData, finalMarkers);
          if (ofMarkers && ofMarkers.length > 0) {
            finalMarkers = ofMarkers;
          }
        } catch (err) {
          log("Optical flow error: " + err.message);
        }
      }
      
      return finalMarkers;
    }
    
    function areMarkersClose(marker1, marker2) {
      var center1 = {x: 0, y: 0};
      var center2 = {x: 0, y: 0};
      
      for (var i = 0; i < 4; i++) {
        center1.x += marker1.corners[i].x;
        center1.y += marker1.corners[i].y;
        center2.x += marker2.corners[i].x;
        center2.y += marker2.corners[i].y;
      }
      
      center1.x /= 4;
      center1.y /= 4;
      center2.x /= 4;
      center2.y /= 4;
      
      var dx = center1.x - center2.x;
      var dy = center1.y - center2.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      
      return distance < 20;
    }
    
    function snapshot() {
      try {
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      } catch (err) {
        log("Error taking snapshot: " + err.message);
      }
    }
    
    function drawMarkers(markers) {
      if (!markers || markers.length === 0) return;
      
      for (var i = 0; i < markers.length; i++) {
        var corners = markers[i].corners;
        var id = markers[i].id;
        
        // Draw marker outline
        context.lineWidth = 3;
        context.strokeStyle = "green";
        context.beginPath();
        context.moveTo(corners[0].x, corners[0].y);
        context.lineTo(corners[1].x, corners[1].y);
        context.lineTo(corners[2].x, corners[2].y);
        context.lineTo(corners[3].x, corners[3].y);
        context.lineTo(corners[0].x, corners[0].y);
        context.stroke();
        context.closePath();
        
        // Draw marker ID label
        var centerX = 0, centerY = 0;
        for (var j = 0; j < 4; j++) {
          centerX += corners[j].x;
          centerY += corners[j].y;
        }
        centerX /= 4;
        centerY /= 4;
        
        context.fillStyle = "white";
        context.font = "bold 12px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        
        var text = "ID: " + id;
        var textWidth = context.measureText(text).width;
        context.fillRect(centerX - textWidth/2 - 2, centerY - 8, textWidth + 4, 16);
        
        context.fillStyle = "black";
        context.fillText(text, centerX, centerY);
      }
    }

    // Helper to load an STL from the "models/" folder,
    // caching the geometry to avoid repeated requests.
    function loadStl(stlName, onLoadCallback) {
      // If already cached, return it
      if (stlCache[stlName]) {
        onLoadCallback(stlCache[stlName]);
        return;
      }
      // Otherwise, load and cache it
      stlLoader.load('models/' + stlName, function (geometry) {
        geometry.computeBoundingBox();
        // Center the geometry
        var min = geometry.boundingBox.min;
        var max = geometry.boundingBox.max;
        var center = new THREE.Vector3().addVectors(min, max).multiplyScalar(0.5);
        var offset = center.clone().multiplyScalar(-1);
        
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x, offset.y, offset.z));
        
        stlCache[stlName] = geometry; // Cache it
        onLoadCallback(geometry);
      });
    }

    function updateScene(markers) {
      // Remove all children from scene except camera & lights (first 3)
      while (scene.children.length > 3) {
        scene.remove(scene.children[3]);
      }
      
      // Make a map from markerId -> marker data
      // so we can look up quickly by ID.
      var markerMap = {};
      for (var i = 0; i < markers.length; i++) {
        markerMap[markers[i].id] = markers[i];
      }
      
      // For each scenario, see if its identifier tag is present.
      // If so, show that scenarioâ€™s objects (for whichever object tags appear).
      for (var s = 0; s < scenarios.length; s++) {
        var scenario = scenarios[s];
        if (markerMap[scenario.identifierTag]) {
          // The scenario is "active"; let's see which object tags are present
          for (var o = 0; o < scenario.objects.length; o++) {
            var objData = scenario.objects[o];
            var objTag = objData.tag;
            if (markerMap[objTag]) {
              // This object tag is visible; place the corresponding STL
              placeObject(markerMap[objTag], objData.stl);
            }
          }
        }
      }
    }
    
    // Clones and places the appropriate STL geometry at the position of the given marker
    function placeObject(marker, stlFile) {
      // Convert marker corners to camera coordinates for POSIT
      var corners = [];
      for (var i = 0; i < marker.corners.length; i++) {
        corners.push({
          x: marker.corners[i].x - (canvas.width / 2),
          y: (canvas.height / 2) - marker.corners[i].y
        });
      }
      var pose = posit.pose(corners);
      
      // Load (or retrieve from cache) the STL geometry
      loadStl(stlFile, function(geometry) {
        // Create a mesh
        var material = new THREE.MeshPhongMaterial({ color: 0x6688aa });
        var mesh = new THREE.Mesh(geometry, material);

        // Scale the mesh for display
        mesh.scale.set(0.05 * modelSize, 0.05 * modelSize, 0.05 * modelSize);

        // Calculate rotation
        var r = pose.bestRotation;
        mesh.rotation.x = -Math.asin(-r[1][2]);
        mesh.rotation.y = -Math.atan2(r[0][2], r[2][2]);
        mesh.rotation.z = Math.atan2(r[1][0], r[1][1]);

        // Calculate position
        mesh.position.x = pose.bestTranslation[0];
        mesh.position.y = pose.bestTranslation[1];
        mesh.position.z = -pose.bestTranslation[2];

        // Add to scene
        scene.add(mesh);
      });
    }
    
    function updateMarkerInfo(markers) {
      var counts = {};
      for (var i = 0; i < markers.length; i++) {
        var id = markers[i].id;
        counts[id] = (counts[id] || 0) + 1;
      }
      
      var html = "<strong>Detected Markers: " + markers.length + "</strong>";
      
      if (Object.keys(counts).length > 0) {
        html += "<ul>";
        for (var id in counts) {
          html += "<li>ID " + id + ": " + counts[id] + " marker(s)</li>";
        }
        html += "</ul>";
      }
      
      document.getElementById("markerInfo").innerHTML = html;
    }
    
    function toggleAdaptiveFilter() {
      useAdaptiveFilter = document.getElementById("useATF").checked;
      log("Adaptive Threshold Filter: " + (useAdaptiveFilter ? "ON" : "OFF"));
    }
    
    function toggleMultiScale() {
      useMultiScale = document.getElementById("useMultiScale").checked;
      log("Multi-Scale Detection: " + (useMultiScale ? "ON" : "OFF"));
    }
    
    function toggleOpticalFlow() {
      useOpticalFlow = document.getElementById("useOpticalFlow").checked;
      if (!useOpticalFlow) {
        opticalFlowTracker.reset();
      }
      log("Optical Flow Tracking: " + (useOpticalFlow ? "ON" : "OFF"));
    }
    
    function log(message) {
      console.log(message);
      if (debugElement) {
        debugElement.innerHTML += message + "<br>";
        var lines = debugElement.innerHTML.split("<br>");
        if (lines.length > 12) {
          debugElement.innerHTML = lines.slice(lines.length - 12).join("<br>");
        }
      }
    }
    
    window.onload = onLoad;
  </script>  

  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 10px;
      background-color: #f0f0f0;
    }
    
    .container {
      width: 650px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    h2 {
      color: #00aa00;
      margin-top: 0;
    }
    
    .filter-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 10px 0;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
    }
    
    .filter-control {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .views {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .view {
      border: solid 2px #00aa00;
      border-radius: 5px;
      flex: 1;
      overflow: hidden;
      position: relative;
    }
    
    .view-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(0,0,0,0.5);
      color: white;
      padding: 5px;
      font-size: 12px;
    }
    
    .info {
      background: #f8f8f8;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
      text-align: left;
      margin-bottom: 10px;
      min-height: 100px;
    }
    
    .debug-panel {
      background: #333;
      color: #0f0;
      font-family: monospace;
      padding: 10px;
      border-radius: 5px;
      text-align: left;
      margin-top: 10px;
      height: 150px;
      overflow-y: auto;
      font-size: 12px;
    }
    
    #canvas {
      width: 100%;
      height: 100%;
    }
    
    #container {
      width: 320px;
      height: 240px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Simple AR System with Automata Scenarios</h2>
    
    <div class="filter-controls">
      <div class="filter-control">
        <input type="checkbox" id="useATF" onchange="toggleAdaptiveFilter()">
        <label for="useATF">Adaptive Threshold</label>
      </div>
      
      <div class="filter-control">
        <input type="checkbox" id="useMultiScale" onchange="toggleMultiScale()">
        <label for="useMultiScale">Multi-Scale</label>
      </div>
      
      <div class="filter-control">
        <input type="checkbox" id="useOpticalFlow" onchange="toggleOpticalFlow()">
        <label for="useOpticalFlow">Optical Flow</label>
      </div>
    </div>
    
    <div class="views">
      <div class="view">
        <canvas id="canvas"></canvas>
        <div class="view-label">Camera View</div>
      </div>
      
      <div class="view">
        <div id="container"></div>
        <div class="view-label">AR View</div>
      </div>
    </div>
    
    <div class="info">
      <div id="markerInfo">Waiting for markers...</div>
    </div>
    
    <div class="debug-panel">
      <div id="debug">System initializing...</div>
    </div>
  </div>
  
  <!-- Hidden video for streaming camera frames -->
  <video id="video" width="320" height="240" autoplay="true" style="display:none;"></video>
</body>
</html>