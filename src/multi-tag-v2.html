<!DOCTYPE html>
<html>

<head>
  <title>Basic Multi-Marker AR</title>

  <script type="text/javascript" src="libs/Three.js"></script>
  <script type="text/javascript" src="libs/STLLoader.js"></script>
  <script type="text/javascript" src="svd.js"></script> 
  <script type="text/javascript" src="posit1.js"></script> 
  <script type="text/javascript" src="cv.js"></script> 
  <script type="text/javascript" src="aruco.js"></script> 
  <script type="text/javascript" src="atf.js"></script>
  <script type="text/javascript" src="multiS.js"></script>
  <script type="text/javascript" src="optic.js"></script>

  <script type="text/javascript">
    var video, canvas, context, imageData, detector, posit;
    var renderer, scene, camera, backgroundScene, backgroundCamera, videoTexture;
    var adaptiveFilter, multiScaleDetector, opticalFlowTracker;
    var useAdaptiveFilter = false;
    var useMultiScale = false;
    var useOpticalFlow = false;
    var modelSize = 35.0; // millimeters
    var debugElement;
  
    // Store the loaded STL model (or mesh) so we can clone it per marker
    var gStlModel = null;
  
    function onLoad() {
      // Initialize DOM elements
      video = document.getElementById("video");
      canvas = document.getElementById("canvas");
      context = canvas.getContext("2d");
      debugElement = document.getElementById("debug");
      
      // Set canvas dimensions
      canvas.width = 320;
      canvas.height = 240;
      
      log("Initializing...");
      
      // Initialize camera
      initCamera();
      
      // Initialize detector
      detector = new AR.Detector();
      posit = new POS.Posit(modelSize, canvas.width);
      log("Base detector initialized");
      
      // Initialize filters
      initFilters();
      
      // Initialize renderer and scene
      initRenderer();
      
      // Start animation loop
      requestAnimationFrame(tick);
    }
    
    function initFilters() {
      // Adaptive Threshold Filter
      adaptiveFilter = new AdaptiveThresholdFilter({
        blockSize: 21,
        C: 5,
        useIntegralImage: true
      });
      log("Adaptive threshold filter initialized");
      
      // Multi-Scale Detector
      multiScaleDetector = new MultiScaleDetector({
        detector: detector, 
        scales: [1.0, 0.5, 1.5],
        confidenceThreshold: 0.3
      });
      log("Multi-scale detector initialized");
      
      // Optical Flow Tracker
      opticalFlowTracker = new OpticalFlowTracker({
        winSize: 15,
        maxError: 10000,
        maxMotion: 50,
        maxTrackedFrames: 30
      });
      log("Optical flow tracker initialized");
      
      // Set initial checkbox states
      document.getElementById('useATF').checked = useAdaptiveFilter;
      document.getElementById('useMultiScale').checked = useMultiScale;
      document.getElementById('useOpticalFlow').checked = useOpticalFlow;
      
      log("Adaptive Threshold Filter: OFF");
      log("Multi-Scale Detection: OFF");
      log("Optical Flow Tracking: OFF");
    }
    
    function initRenderer() {
      // Set up renderer
      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setClearColor(0xffffff, 1);
      renderer.setSize(canvas.width, canvas.height);
      document.getElementById("container").appendChild(renderer.domElement);
      
      // Set up video texture
      videoTexture = new THREE.Texture(video);
      videoTexture.minFilter = THREE.LinearFilter;
      
      // Create background scene with video texture
      backgroundScene = new THREE.Scene();
      backgroundCamera = new THREE.Camera();
      
      var plane = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2, 0),
        new THREE.MeshBasicMaterial({map: videoTexture, depthTest: false, depthWrite: false})
      );
      plane.material.side = THREE.DoubleSide;
      plane.position.z = -1;
      
      backgroundScene.add(backgroundCamera);
      backgroundScene.add(plane);
      
      // Create main AR scene
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(40, canvas.width / canvas.height, 1, 1000);
      scene.add(camera);
      
      // Add lights
      var ambientLight = new THREE.AmbientLight(0x666666);
      scene.add(ambientLight);
      
      var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
      directionalLight.position.set(0, 0, 1);
      scene.add(directionalLight);
      
      log("Renderer initialized");
  
      // === LOAD STL MODEL ===
      // We assume STLLoader is available globally from STLLoader.js
      var loader = new THREE.STLLoader();
      loader.load('models/rocktopus.stl', function (geometry) {
        // 1) Make sure bounding box is computed
        geometry.computeBoundingBox();

        // 2) Calculate center
        var min = geometry.boundingBox.min; // r70 style
        var max = geometry.boundingBox.max;
        var center = new THREE.Vector3();
        center.addVectors(min, max).multiplyScalar(0.5);

        // 3) Translate geometry so center is at (0,0,0)
        var offset = center.clone().multiplyScalar(-1);
        geometry.applyMatrix(
          new THREE.Matrix4().makeTranslation(offset.x, offset.y, offset.z)
        );

        // Now geometry is centered at origin
        var material = new THREE.MeshPhongMaterial({ color: 0x6688aa });
        var mesh = new THREE.Mesh(geometry, material);

        // If needed, rotate or scale further:
        // mesh.rotation.x = -Math.PI / 2;
        // mesh.scale.set(0.05, 0.05, 0.05);

        gStlModel = mesh;

        log("STL model loaded and centered for r70.");
      })};
    
    function initCamera() {
      log("Initializing camera...");
      
      if (navigator.mediaDevices === undefined) {
        navigator.mediaDevices = {};
      }
      
      if (navigator.mediaDevices.getUserMedia === undefined) {
        navigator.mediaDevices.getUserMedia = function(constraints) {
          var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
          
          if (!getUserMedia) {
            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
          }
    
          return new Promise(function(resolve, reject) {
            getUserMedia.call(navigator, constraints, resolve, reject);
          });
        }
      }
      
      navigator.mediaDevices
        .getUserMedia({ video: true })
        .then(function(stream) {
          log("Camera access granted");
          if ("srcObject" in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }
          video.play();
        })
        .catch(function(err) {
          log("Camera error: " + err.message);
        });
    }
    
    function tick() {
      requestAnimationFrame(tick);
      
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        // Capture frame
        snapshot();
        
        // Update video texture for AR view
        videoTexture.needsUpdate = true;
        
        // Detect markers (base detection first)
        var markers = detector.detect(imageData);
        
        // Apply active filters
        markers = processFilters(markers);
        
        // Draw markers on canvas
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        drawMarkers(markers);
        
        // Update 3D scene
        updateScene(markers);
        
        // Render
        renderer.autoClear = false;
        renderer.clear();
        renderer.render(backgroundScene, backgroundCamera);
        renderer.render(scene, camera);
        
        // Update info
        updateMarkerInfo(markers);
      }
    }
    
    function processFilters(markers) {
      var finalMarkers = markers.slice();
      
      // Adaptive Threshold Filter
      if (useAdaptiveFilter) {
        try {
          var processedImageData = adaptiveFilter.process(imageData);
          var atfMarkers = detector.detect(processedImageData);
          
          // Merge new markers
          for (var i = 0; i < atfMarkers.length; i++) {
            var isNew = true;
            for (var j = 0; j < finalMarkers.length; j++) {
              if (atfMarkers[i].id === finalMarkers[j].id && areMarkersClose(atfMarkers[i], finalMarkers[j])) {
                isNew = false;
                break;
              }
            }
            if (isNew) {
              finalMarkers.push(atfMarkers[i]);
            }
          }
        } catch (err) {
          log("ATF error: " + err.message);
        }
      }
      
      // Multi-scale detection
      if (useMultiScale) {
        try {
          var msMarkers = multiScaleDetector.detect(imageData);
          for (var i = 0; i < msMarkers.length; i++) {
            var isNew = true;
            for (var j = 0; j < finalMarkers.length; j++) {
              if (msMarkers[i].id === finalMarkers[j].id && areMarkersClose(msMarkers[i], finalMarkers[j])) {
                isNew = false;
                break;
              }
            }
            if (isNew) {
              finalMarkers.push(msMarkers[i]);
            }
          }
        } catch (err) {
          log("Multi-scale error: " + err.message);
        }
      }
      
      // Optical flow
      if (useOpticalFlow) {
        try {
          var ofMarkers = opticalFlowTracker.track(imageData, finalMarkers);
          if (ofMarkers && ofMarkers.length > 0) {
            finalMarkers = ofMarkers;
          }
        } catch (err) {
          log("Optical flow error: " + err.message);
        }
      }
      
      return finalMarkers;
    }
    
    function areMarkersClose(marker1, marker2) {
      var center1 = {x: 0, y: 0};
      var center2 = {x: 0, y: 0};
      
      for (var i = 0; i < 4; i++) {
        center1.x += marker1.corners[i].x;
        center1.y += marker1.corners[i].y;
        center2.x += marker2.corners[i].x;
        center2.y += marker2.corners[i].y;
      }
      
      center1.x /= 4;
      center1.y /= 4;
      center2.x /= 4;
      center2.y /= 4;
      
      var dx = center1.x - center2.x;
      var dy = center1.y - center2.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      
      return distance < 20;
    }
    
    function snapshot() {
      try {
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      } catch (err) {
        log("Error taking snapshot: " + err.message);
      }
    }
    
    function drawMarkers(markers) {
      if (!markers || markers.length === 0) return;
      
      for (var i = 0; i < markers.length; i++) {
        var corners = markers[i].corners;
        var id = markers[i].id;
        
        // Draw marker outline
        context.lineWidth = 3;
        context.strokeStyle = "green";
        context.beginPath();
        context.moveTo(corners[0].x, corners[0].y);
        context.lineTo(corners[1].x, corners[1].y);
        context.lineTo(corners[2].x, corners[2].y);
        context.lineTo(corners[3].x, corners[3].y);
        context.lineTo(corners[0].x, corners[0].y);
        context.stroke();
        context.closePath();
        
        // Draw marker ID
        var centerX = 0, centerY = 0;
        for (var j = 0; j < 4; j++) {
          centerX += corners[j].x;
          centerY += corners[j].y;
        }
        centerX /= 4;
        centerY /= 4;
        
        context.fillStyle = "white";
        context.font = "bold 12px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        
        var text = "ID: " + id;
        var textWidth = context.measureText(text).width;
        context.fillRect(centerX - textWidth / 2 - 2, centerY - 8, textWidth + 4, 16);
        
        context.fillStyle = "black";
        context.fillText(text, centerX, centerY);
      }
    }
    
    function updateScene(markers) {
      // Remove all children from scene except camera and lights (first 3)
      while (scene.children.length > 3) {
        scene.remove(scene.children[3]);
      }
      
      // Create a model for each marker
      for (var i = 0; i < markers.length; i++) {
        var marker = markers[i];
        var model = createModel(marker.id);
        
        // Convert corners to camera coordinate system
        var corners = [];
        for (var j = 0; j < marker.corners.length; j++) {
          corners.push({
            x: marker.corners[j].x - (canvas.width / 2),
            y: (canvas.height / 2) - marker.corners[j].y
          });
        }
        
        // Calculate pose
        var pose = posit.pose(corners);
        
        // Update model transforms
        updateObject(model, pose.bestRotation, pose.bestTranslation);
        
        // Add to scene
        scene.add(model);
      }
    }
    
    // Replaces the old procedural boat with an STL-based model
    function createModel(markerId) {
      // If STL not loaded yet, return an empty placeholder so we don't crash
      if (!gStlModel) {
        return new THREE.Object3D();
      }
      
      // Clone the loaded STL mesh so each marker has its own copy
      var object = gStlModel.clone();
      
      // (Optional) give each marker ID a unique color:
      // var hue = ((markerId * 137) % 360) / 360;
      // object.material = object.material.clone();
      // object.material.color.setHSL(hue, 0.5, 0.5);
      
      return object;
    }
  
    function updateObject(object, rotation, translation) {
      // Adjust scale as needed for your STL
      object.scale.set(0.05 * modelSize, 0.05 * modelSize, 0.05 * modelSize);
  
      // Existing rotation logic
      object.rotation.x = -Math.asin(-rotation[1][2]);
      object.rotation.y = -Math.atan2(rotation[0][2], rotation[2][2]);
      object.rotation.z = Math.atan2(rotation[1][0], rotation[1][1]);
      
      // Position
      object.position.x = translation[0];
      object.position.y = translation[1];
      object.position.z = -translation[2];
    }
    
    function updateMarkerInfo(markers) {
      var counts = {};
      for (var i = 0; i < markers.length; i++) {
        var id = markers[i].id;
        counts[id] = (counts[id] || 0) + 1;
      }
      
      var html = "<strong>Detected Markers: " + markers.length + "</strong>";
      
      if (Object.keys(counts).length > 0) {
        html += "<ul>";
        for (var id in counts) {
          html += "<li>ID " + id + ": " + counts[id] + " marker(s)</li>";
        }
        html += "</ul>";
      }
      
      document.getElementById("markerInfo").innerHTML = html;
    }
    
    function toggleAdaptiveFilter() {
      useAdaptiveFilter = document.getElementById("useATF").checked;
      log("Adaptive Threshold Filter: " + (useAdaptiveFilter ? "ON" : "OFF"));
    }
    
    function toggleMultiScale() {
      useMultiScale = document.getElementById("useMultiScale").checked;
      log("Multi-Scale Detection: " + (useMultiScale ? "ON" : "OFF"));
    }
    
    function toggleOpticalFlow() {
      useOpticalFlow = document.getElementById("useOpticalFlow").checked;
      if (!useOpticalFlow) {
        opticalFlowTracker.reset();
      }
      log("Optical Flow Tracking: " + (useOpticalFlow ? "ON" : "OFF"));
    }
    
    function log(message) {
      console.log(message);
      if (debugElement) {
        debugElement.innerHTML += message + "<br>";
        var lines = debugElement.innerHTML.split("<br>");
        if (lines.length > 12) {
          debugElement.innerHTML = lines.slice(lines.length - 12).join("<br>");
        }
      }
    }
    
    window.onload = onLoad;
  </script>  

  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 10px;
      background-color: #f0f0f0;
    }
    
    .container {
      width: 650px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    h2 {
      color: #00aa00;
      margin-top: 0;
    }
    
    .filter-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 10px 0;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
    }
    
    .filter-control {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .views {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .view {
      border: solid 2px #00aa00;
      border-radius: 5px;
      flex: 1;
      overflow: hidden;
      position: relative;
    }
    
    .view-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(0,0,0,0.5);
      color: white;
      padding: 5px;
      font-size: 12px;
    }
    
    .info {
      background: #f8f8f8;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
      text-align: left;
      margin-bottom: 10px;
      min-height: 100px;
    }
    
    .debug-panel {
      background: #333;
      color: #0f0;
      font-family: monospace;
      padding: 10px;
      border-radius: 5px;
      text-align: left;
      margin-top: 10px;
      height: 150px;
      overflow-y: auto;
      font-size: 12px;
    }
    
    #canvas {
      width: 100%;
      height: 100%;
    }
    
    #container {
      width: 320px;
      height: 240px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Simple AR System with Filter Controls</h2>
    
    <div class="filter-controls">
      <div class="filter-control">
        <input type="checkbox" id="useATF" onchange="toggleAdaptiveFilter()">
        <label for="useATF">Adaptive Threshold</label>
      </div>
      
      <div class="filter-control">
        <input type="checkbox" id="useMultiScale" onchange="toggleMultiScale()">
        <label for="useMultiScale">Multi-Scale</label>
      </div>
      
      <div class="filter-control">
        <input type="checkbox" id="useOpticalFlow" onchange="toggleOpticalFlow()">
        <label for="useOpticalFlow">Optical Flow</label>
      </div>
    </div>
    
    <div class="views">
      <div class="view">
        <canvas id="canvas"></canvas>
        <div class="view-label">Camera View</div>
      </div>
      
      <div class="view">
        <div id="container"></div>
        <div class="view-label">AR View</div>
      </div>
    </div>
    
    <div class="info">
      <div id="markerInfo">Waiting for markers...</div>
    </div>
    
    <div class="debug-panel">
      <div id="debug">System initializing...</div>
    </div>
  </div>
  
  <video id="video" width="320" height="240" autoplay="true" style="display:none;"></video>
</body>
</html>
